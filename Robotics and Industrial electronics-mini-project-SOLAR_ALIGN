//Robotics and industrial electronics
//mini-project
//SOLAR-ALIGN

----------------------------------

//east/west test
// Simple AZIMUTH test: 2.5s right, 2.5s left, 2.5s stop, repeat

int AZ1 = 2;
int AZ2 = 3;
int AZ3 = 4;
int AZ4 = 5;

int stepDelay = 5;  // ms between micro-steps

void setup() {
  pinMode(AZ1, OUTPUT);
  pinMode(AZ2, OUTPUT);
  pinMode(AZ3, OUTPUT);
  pinMode(AZ4, OUTPUT);

  stopMotor();
}

void loop() {

  // ---- 2.5s RIGHT ----
  unsigned long t0 = millis();
  while (millis() - t0 < 2500) {
    stepRight();
  }

  stopMotor();        // small pause between directions
  delay(10);

  // ---- 2.5s LEFT ----
  t0 = millis();
  while (millis() - t0 < 2500) {
    stepLeft();
  }

  // ---- 2.5s STOP ----
  stopMotor();
  delay(2500);        // stays still 2.5s

  // then loop() repeats forever
}

// ----- Step patterns (same idea as your main code) -----
void stepRight() {
  digitalWrite(AZ1, HIGH); digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, HIGH); digitalWrite(AZ4, LOW);
  delay(stepDelay);

  digitalWrite(AZ1, LOW); digitalWrite(AZ2, HIGH);
  digitalWrite(AZ3, HIGH); digitalWrite(AZ4, LOW);
  delay(stepDelay);

  digitalWrite(AZ1, LOW); digitalWrite(AZ2, HIGH);
  digitalWrite(AZ3, LOW); digitalWrite(AZ4, HIGH);
  delay(stepDelay);

  digitalWrite(AZ1, HIGH); digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, LOW); digitalWrite(AZ4, HIGH);
  delay(stepDelay);
}

void stepLeft() {
  digitalWrite(AZ1, HIGH); digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, LOW); digitalWrite(AZ4, HIGH);
  delay(stepDelay);

  digitalWrite(AZ1, LOW); digitalWrite(AZ2, HIGH);
  digitalWrite(AZ3, LOW); digitalWrite(AZ4, HIGH);
  delay(stepDelay);

  digitalWrite(AZ1, LOW); digitalWrite(AZ2, HIGH);
  digitalWrite(AZ3, HIGH); digitalWrite(AZ4, LOW);
  delay(stepDelay);

  digitalWrite(AZ1, HIGH); digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, HIGH); digitalWrite(AZ4, LOW);
  delay(stepDelay);
}

void stopMotor() {
  digitalWrite(AZ1, LOW);
  digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, LOW);
  digitalWrite(AZ4, LOW);
}
//Ldr-volt-test
// LDR Voltage Test on A0–A3
// Simple and clean

const float Vref = 5.0;   // Arduino Nano reference voltage

void setup() {
  Serial.begin(9600);
}

void loop() {

  int LDR1 = analogRead(A0);
  int LDR2 = analogRead(A1);
  int LDR3 = analogRead(A2);
  int LDR4 = analogRead(A3);

  float V1 = (LDR1 * Vref) / 1023.0;
  float V2 = (LDR2 * Vref) / 1023.0;
  float V3 = (LDR3 * Vref) / 1023.0;
  float V4 = (LDR4 * Vref) / 1023.0;

  Serial.println("------ LDR TEST ------");

  Serial.print("LDR1 (A0): Raw = ");
  Serial.print(LDR1);
  Serial.print("  Voltage = ");
  Serial.print(V1, 3);
  Serial.println(" V");

  Serial.print("LDR2 (A1): Raw = ");
  Serial.print(LDR2);
  Serial.print("  Voltage = ");
  Serial.print(V2, 3);
  Serial.println(" V");

  Serial.print("LDR3 (A2): Raw = ");
  Serial.print(LDR3);
  Serial.print("  Voltage = ");
  Serial.print(V3, 3);
  Serial.println(" V");

  Serial.print("LDR4 (A3): Raw = ");
  Serial.print(LDR4);
  Serial.print("  Voltage = ");
  Serial.print(V4, 3);
  Serial.println(" V");

  Serial.println("----------------------");
  Serial.println();

  delay(500);
}

// mini-proj-prototype-code-c22718249
// --------------------------------------
// --------- "SOLAR-ALIGN" --------------
// - simple-solar-tracking-system-MINI-PROJECT
// 5-wire stepper (E/W) + 4-wire stepper (N/S)
//
// By-Daryl-Sweeney
// student number:c22718249
// TU705/3
//
// version 1.0
//
// checked-errors with chat-gpt
// --------------------------------------

// LDR inputs
int LDR_TOP    = A0;  //light-dependent-resistor-north
int LDR_BOTTOM = A1;  //light-dependent-resistor-south
int LDR_LEFT   = A2;  //light-dependent-resistor-east
int LDR_RIGHT  = A3;  //light-dependent-resistor-west

// 5-wire stepper pins (360 degrees) EAST/WEST - Azimuth
int AZ1 = 2;
int AZ2 = 3;
int AZ3 = 4;
int AZ4 = 5;

// 4-wire stepper pins (approx-180 degrees) NORTH/SOUTH - Elevation
int EL1 = 6;
int EL2 = 7;
int EL3 = 8;
int EL4 = 9;

int deadband = 50;   // ignore small differences
int stepDelay = 5;   // motor speed


// --------------------------------------
void setup() {
  Serial.begin(9600);// link between arduino/laptop @ 9600 baudrate

  //Azimuth movement-east/west pins
  pinMode(AZ1, OUTPUT);
  pinMode(AZ2, OUTPUT);
  pinMode(AZ3, OUTPUT);
  pinMode(AZ4, OUTPUT);

  //Elevation movement-north/south pins
  pinMode(EL1, OUTPUT);
  pinMode(EL2, OUTPUT);
  pinMode(EL3, OUTPUT);
  pinMode(EL4, OUTPUT);

  stopMotors();
}


// --------------------------------------
void loop() {

  //reading LDR pins
  int top    = analogRead(LDR_TOP);
  int bottom = analogRead(LDR_BOTTOM);
  int left   = analogRead(LDR_LEFT);
  int right  = analogRead(LDR_RIGHT);

  //combining into two values - x and y for position of most light
  int vertical   = top - bottom;
  int horizontal = right - left;

  // Move North/South (4-wire stepper)
  
  //if theres more light(vertically) than deadband and more
  //than zero turn in the direction of maximum light
  
  if (abs(vertical) > deadband) {
    if (vertical > 0) {
      stepElevationUp();
    } else {
      stepElevationDown();
    }
  }

  // Move East/West (5-wire stepper)
  
  //if theres more light(horizontally) than deadband and more
  //than zero turn in the direction of maximum light
  
  if (abs(horizontal) > deadband) {
    if (horizontal > 0) {
      stepRight();
    } else {
      stepLeft();
    }
  }

  //then stop motors for 30 milliseconds
  stopMotors(); //stopmotor-function
  delay(30); //delay 30 milliseconds
  
  //run loop again
}


// --------------------------------------
// 5-wire stepper-(East/West)-Azimuth
// This is a unipolar stepper so one coil is magnetised at once
// --------------------------------------

// step right
void stepRight() {
  digitalWrite(AZ1, HIGH);
  digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, LOW);
  digitalWrite(AZ4, LOW);
  delay(stepDelay);
  
  digitalWrite(AZ1, LOW);
  digitalWrite(AZ2, HIGH);
  delay(stepDelay);
  
  digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, HIGH);
  delay(stepDelay);
  
  digitalWrite(AZ3, LOW); 
  digitalWrite(AZ4, HIGH);
  delay(stepDelay);
}

// step left
void stepLeft() {
  digitalWrite(AZ4, HIGH);
  delay(stepDelay);
  
  digitalWrite(AZ4, LOW);
  digitalWrite(AZ3, HIGH);
  delay(stepDelay);
  
  digitalWrite(AZ3, LOW);
  digitalWrite(AZ2, HIGH);
  delay(stepDelay);
  
  digitalWrite(AZ2, LOW);
  digitalWrite(AZ1, HIGH);
  delay(stepDelay);
}


// --------------------------------------
// 4-wire stepper (North/South)
// This is a bipolar stepper so two poles are magnetised at once
// --------------------------------------

// elevate up
void stepElevationUp() {
  digitalWrite(EL1, HIGH);
  digitalWrite(EL2, LOW);
  digitalWrite(EL3, HIGH);
  digitalWrite(EL4, LOW);
  delay(stepDelay);

  digitalWrite(EL1, LOW);
  digitalWrite(EL2, HIGH);
  digitalWrite(EL3, HIGH);
  digitalWrite(EL4, LOW);
  delay(stepDelay);

  digitalWrite(EL1, LOW);
  digitalWrite(EL2, HIGH);
  digitalWrite(EL3, LOW);
  digitalWrite(EL4, HIGH);
  delay(stepDelay);

  digitalWrite(EL1, HIGH);
  digitalWrite(EL2, LOW);
  digitalWrite(EL3, LOW);
  digitalWrite(EL4, HIGH);
  delay(stepDelay);
}

// elevate down
void stepElevationDown() {
  digitalWrite(EL1, HIGH);
  digitalWrite(EL2, LOW);
  digitalWrite(EL3, LOW);
  delay(stepDelay);
  digitalWrite(EL4, HIGH);

  digitalWrite(EL1, LOW);
  digitalWrite(EL2, HIGH);
  digitalWrite(EL3, LOW);
  digitalWrite(EL4, HIGH);
  delay(stepDelay);

  digitalWrite(EL1, LOW);
  digitalWrite(EL2, HIGH);
  digitalWrite(EL3, HIGH);
  digitalWrite(EL4, LOW);
  delay(stepDelay);

  digitalWrite(EL1, HIGH);
  digitalWrite(EL2, LOW);
  digitalWrite(EL3, HIGH);
  digitalWrite(EL4, LOW);
  delay(stepDelay);
}


// --------------------------------------
// ---------stop-motor-function----------
void stopMotors() {
  digitalWrite(AZ1, LOW);
  digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, LOW);
  digitalWrite(AZ4, LOW);

  digitalWrite(EL1, LOW);
  digitalWrite(EL2, LOW);
  digitalWrite(EL3, LOW);
  digitalWrite(EL4, LOW);
}
 

// mini-proj-prototype-code-c22718249-version-1_1
// --------------------------------------
// --------- "SOLAR-ALIGN" --------------
// - simple-solar-tracking-system-MINI-PROJECT
// 4-wire stepper (E/W) + 4-wire stepper (N/S)
// mini-proj-prototype-code-c22718249-version-1_2
// version 1.2
// --------------------------------------

//LDR-Solar-Panel-Locations
int LDR_TOP    = A0;
int LDR_BOTTOM = A1;
int LDR_LEFT   = A2;
int LDR_RIGHT  = A3;

int SOLAR_VOLT_1 = A4; //Voltage sample from Voltage divider
int SOLAR_VOLT_2 = A5; //Voltage sample from Fan node - for current

// Stepper pins
int AZ1 = 2;
int AZ2 = 3;
int AZ3 = 4;
int AZ4 = 5;

int EL1 = 6;
int EL2 = 7;
int EL3 = 8;
int EL4 = 9;

// LOCK LED
int LOCK_LED = 13;

// settings
int deadband = 50;
int stepDelay = 5;


// --------------------------------------
void setup() {
  Serial.begin(9600);

  pinMode(AZ1, OUTPUT);
  pinMode(AZ2, OUTPUT);
  pinMode(AZ3, OUTPUT);
  pinMode(AZ4, OUTPUT);

  pinMode(EL1, OUTPUT);
  pinMode(EL2, OUTPUT);
  pinMode(EL3, OUTPUT);
  pinMode(EL4, OUTPUT);

  pinMode(LOCK_LED, OUTPUT);
  digitalWrite(LOCK_LED, LOW);

  stopMotors();
}


// --------------------------------------
void loop() {

  int top    = analogRead(LDR_TOP);
  int bottom = analogRead(LDR_BOTTOM);
  int left   = analogRead(LDR_LEFT);
  int right  = analogRead(LDR_RIGHT);

  int solar_voltage_1 = analogRead(SOLAR_VOLT_1);//Voltage Divider Voltage - Vin*(10k/10k+10k)
  int solar_voltage_2 = analogRead(SOLAR_VOLT_2);//Fan Voltage Sample for current
  int AMP_1 = (solar_voltage_1/(10/20));
  int AMP_2 = (solar_voltage_2/1);

  int VOLT_TOTAL = solar_voltage_1 + solar_Voltage_2;
  int AMP_TOTAL = AMP_1 + AMP_2;
  int RES_TOTAL = VOLTAGE_TOTAL/AMP_TOTAL;
  
 


  int vertical   = top - bottom;    // North/South
  int horizontal = right - left;    // East/West

  bool moving = false;

  // NORTH/SOUTH movement
  if (abs(vertical) > deadband) {
    moving = true;
    if (vertical > 0) stepElevationUp();
    else              stepElevationDown();
  }

  // EAST/WEST movement
  if (abs(horizontal) > deadband) {
    moving = true;
    if (horizontal > 0) stepRight();
    else                stepLeft();
  }

  stopMotors();

  // --- LED BEHAVIOUR ---
  if (moving) {
    blinkSearching();     // tracker is adjusting → blink LED
  } else {
    digitalWrite(LOCK_LED, HIGH);   // locked on the sun → LED ON
  }

  delay(30);

  Serial.print("Voltage from solar panel: ");
  Serial.println(VOLT_TOTAL);
  Serial.print(" /n");
  delay(100);

  Serial.print("Amps from solar panel: ");
  Serial.println(AMP_TOTAL);
  Serial.print(" /n");
  delay(100);

  Serial.print("Resistance from solar panel: ");
  Serial.println(RES_TOTAL);
  Serial.print(" /n");
  delay(100);



  
}


// --------------------------------------
// LED BLINK FUNCTION (searching mode)
// --------------------------------------
void blinkSearching() {
  static unsigned long lastToggle = 0;
  static bool ledState = false;

  if (millis() - lastToggle >= 500) {   // 0.5 second blink
    ledState = !ledState;
    digitalWrite(LOCK_LED, ledState);
    lastToggle = millis();
  }
}


// --------------------------------------
// STEPPER MOVEMENT PATTERNS
// --------------------------------------

// EAST/WEST (Azimuth)
void stepRight() {
  digitalWrite(AZ1, HIGH); digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, HIGH); digitalWrite(AZ4, LOW);
  delay(stepDelay);

  digitalWrite(AZ1, LOW); digitalWrite(AZ2, HIGH);
  digitalWrite(AZ3, HIGH); digitalWrite(AZ4, LOW);
  delay(stepDelay);

  digitalWrite(AZ1, LOW); digitalWrite(AZ2, HIGH);
  digitalWrite(AZ3, LOW); digitalWrite(AZ4, HIGH);
  delay(stepDelay);

  digitalWrite(AZ1, HIGH); digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, LOW); digitalWrite(AZ4, HIGH);
  delay(stepDelay);
}

void stepLeft() {
  digitalWrite(AZ1, HIGH); digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, LOW); digitalWrite(AZ4, HIGH);
  delay(stepDelay);

  digitalWrite(AZ1, LOW); digitalWrite(AZ2, HIGH);
  digitalWrite(AZ3, LOW); digitalWrite(AZ4, HIGH);
  delay(stepDelay);

  digitalWrite(AZ1, LOW); digitalWrite(AZ2, HIGH);
  digitalWrite(AZ3, HIGH); digitalWrite(AZ4, LOW);
  delay(stepDelay);

  digitalWrite(AZ1, HIGH); digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, HIGH); digitalWrite(AZ4, LOW);
  delay(stepDelay);
}


// NORTH/SOUTH (Elevation)
void stepElevationUp() {
  digitalWrite(EL1, HIGH); digitalWrite(EL2, LOW);
  digitalWrite(EL3, HIGH); digitalWrite(EL4, LOW);
  delay(stepDelay);

  digitalWrite(EL1, LOW); digitalWrite(EL2, HIGH);
  digitalWrite(EL3, HIGH); digitalWrite(EL4, LOW);
  delay(stepDelay);

  digitalWrite(EL1, LOW); digitalWrite(EL2, HIGH);
  digitalWrite(EL3, LOW); digitalWrite(EL4, HIGH);
  delay(stepDelay);

  digitalWrite(EL1, HIGH); digitalWrite(EL2, LOW);
  digitalWrite(EL3, LOW); digitalWrite(EL4, HIGH);
  delay(stepDelay);
}

void stepElevationDown() {
  digitalWrite(EL1, HIGH); digitalWrite(EL2, LOW);
  digitalWrite(EL3, LOW); digitalWrite(EL4, HIGH);
  delay(stepDelay);

  digitalWrite(EL1, LOW); digitalWrite(EL2, HIGH);
  digitalWrite(EL3, LOW); digitalWrite(EL4, HIGH);
  delay(stepDelay);

  digitalWrite(EL1, LOW); digitalWrite(EL2, HIGH);
  digitalWrite(EL3, HIGH); digitalWrite(EL4, LOW);
  delay(stepDelay);

  digitalWrite(EL1, HIGH); digitalWrite(EL2, LOW);
  digitalWrite(EL3, HIGH); digitalWrite(EL4, LOW);
  delay(stepDelay);
}


// --------------------------------------
void stopMotors() {
  digitalWrite(AZ1, LOW);
  digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, LOW);
  digitalWrite(AZ4, LOW);

  digitalWrite(EL1, LOW);
  digitalWrite(EL2, LOW);
  digitalWrite(EL3, LOW);
  digitalWrite(EL4, LOW);
}
// ---- Stepper 1 (driver chip 1) ----
const int M1_IN1 = 8;   // 1A
const int M1_IN2 = 7;   // 2A
const int M1_IN3 = 9;   // 3A
const int M1_IN4 = 10;  // 4A

// ---- Stepper 2 (driver chip 2) ----
const int M2_IN1 = 2;   // 1A
const int M2_IN2 = 3;   // 2A
const int M2_IN3 = 4;   // 3A
const int M2_IN4 = 5;   // 4A

// Delay between steps (bigger = slower, safer)
int stepDelay = 5;  // ms

// 4-step full-step sequence (two phases on)
// order: IN1, IN2, IN3, IN4
const int stepTable[4][4] = {
  {1, 0, 1, 0},  // step 0
  {0, 1, 1, 0},  // step 1
  {0, 1, 0, 1},  // step 2
  {1, 0, 0, 1}   // step 3
};

void setup() {
  // Stepper 1 pins
  pinMode(M1_IN1, OUTPUT);
  pinMode(M1_IN2, OUTPUT);
  pinMode(M1_IN3, OUTPUT);
  pinMode(M1_IN4, OUTPUT);

  // Stepper 2 pins
  pinMode(M2_IN1, OUTPUT);
  pinMode(M2_IN2, OUTPUT);
  pinMode(M2_IN3, OUTPUT);
  pinMode(M2_IN4, OUTPUT);

  // If you wired EN pins to Arduino, enable them here, e.g.:
  // pinMode(6, OUTPUT); digitalWrite(6, HIGH); // EN1,2 chip1
  // pinMode(11, OUTPUT); digitalWrite(11, HIGH); // EN3,4 chip1
  // pinMode(12, OUTPUT); digitalWrite(12, HIGH); // EN1,2 chip2
  // pinMode(13, OUTPUT); digitalWrite(13, HIGH); // EN3,4 chip2
}

void loop() {
  // --- Forward 200 steps ---
  for (int i = 0; i < 200; i++) {
    int stepIndex = i % 4;
    stepMotor(M1_IN1, M1_IN2, M1_IN3, M1_IN4, stepIndex);
    stepMotor(M2_IN1, M2_IN2, M2_IN3, M2_IN4, stepIndex);
    delay(stepDelay);
  }
  delay(500);

  // --- Backward 200 steps ---
  for (int i = 0; i < 200; i++) {
    int stepIndex = (3 - (i % 4)); // reverse order
    stepMotor(M1_IN1, M1_IN2, M1_IN3, M1_IN4, stepIndex);
    stepMotor(M2_IN1, M2_IN2, M2_IN3, M2_IN4, stepIndex);
    delay(stepDelay);
  }
  delay(500);
}

// ---- Helper to step one motor ----
void stepMotor(int in1, int in2, int in3, int in4, int stepIndex) {
  digitalWrite(in1, stepTable[stepIndex][0]);
  digitalWrite(in2, stepTable[stepIndex][1]);
  digitalWrite(in3, stepTable[stepIndex][2]);
  digitalWrite(in4, stepTable[stepIndex][3]);
}

// --------------------------------------
// SIMPLE MOTOR TEST for "SOLAR-ALIGN"
// Tests both stepper motors without LDR logic
// --------------------------------------

// Stepper pins (same as your main code)
int AZ1 = 2;
int AZ2 = 3;
int AZ3 = 4;
int AZ4 = 5;

int EL1 = 6;
int EL2 = 7;
int EL3 = 8;
int EL4 = 9;

// LOCK LED (optional)
int LOCK_LED = 13;

// stepper timing
int stepDelay = 5;    // ms between step phases
int testSteps = 50;   // number of 4-phase cycles per move

// --------------------------------------
void setup() {
  Serial.begin(9600);

  pinMode(AZ1, OUTPUT);
  pinMode(AZ2, OUTPUT);
  pinMode(AZ3, OUTPUT);
  pinMode(AZ4, OUTPUT);

  pinMode(EL1, OUTPUT);
  pinMode(EL2, OUTPUT);
  pinMode(EL3, OUTPUT);
  pinMode(EL4, OUTPUT);

  pinMode(LOCK_LED, OUTPUT);
  digitalWrite(LOCK_LED, LOW);

  stopMotors();

  Serial.println("Stepper motor test starting...");
}

// --------------------------------------
void loop() {

  Serial.println("AZIMUTH: RIGHT");
  for (int i = 0; i < testSteps; i++) {
    stepRight();
  }
  stopMotors();
  delay(500);

  Serial.println("AZIMUTH: LEFT");
  for (int i = 0; i < testSteps; i++) {
    stepLeft();
  }
  stopMotors();
  delay(1000);

  Serial.println("ELEVATION: UP");
  for (int i = 0; i < testSteps; i++) {
    stepElevationUp();
  }
  stopMotors();
  delay(500);

  Serial.println("ELEVATION: DOWN");
  for (int i = 0; i < testSteps; i++) {
    stepElevationDown();
  }
  stopMotors();
  delay(1500);

  // flash LED so you know loop is still running
  digitalWrite(LOCK_LED, !digitalRead(LOCK_LED));
}

// --------------------------------------
// STEPPER MOVEMENT PATTERNS (copied from your code)
// --------------------------------------

// EAST/WEST (Azimuth)
void stepRight() {
  digitalWrite(AZ1, HIGH); digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, HIGH); digitalWrite(AZ4, LOW);
  delay(stepDelay);

  digitalWrite(AZ1, LOW); digitalWrite(AZ2, HIGH);
  digitalWrite(AZ3, HIGH); digitalWrite(AZ4, LOW);
  delay(stepDelay);

  digitalWrite(AZ1, LOW); digitalWrite(AZ2, HIGH);
  digitalWrite(AZ3, LOW); digitalWrite(AZ4, HIGH);
  delay(stepDelay);

  digitalWrite(AZ1, HIGH); digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, LOW); digitalWrite(AZ4, HIGH);
  delay(stepDelay);
}

void stepLeft() {
  digitalWrite(AZ1, HIGH); digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, LOW); digitalWrite(AZ4, HIGH);
  delay(stepDelay);

  digitalWrite(AZ1, LOW); digitalWrite(AZ2, HIGH);
  digitalWrite(AZ3, LOW); digitalWrite(AZ4, HIGH);
  delay(stepDelay);

  digitalWrite(AZ1, LOW); digitalWrite(AZ2, HIGH);
  digitalWrite(AZ3, HIGH); digitalWrite(AZ4, LOW);
  delay(stepDelay);

  digitalWrite(AZ1, HIGH); digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, HIGH); digitalWrite(AZ4, LOW);
  delay(stepDelay);
}

// NORTH/SOUTH (Elevation)
void stepElevationUp() {
  digitalWrite(EL1, HIGH); digitalWrite(EL2, LOW);
  digitalWrite(EL3, HIGH); digitalWrite(EL4, LOW);
  delay(stepDelay);

  digitalWrite(EL1, LOW); digitalWrite(EL2, HIGH);
  digitalWrite(EL3, HIGH); digitalWrite(EL4, LOW);
  delay(stepDelay);

  digitalWrite(EL1, LOW); digitalWrite(EL2, HIGH);
  digitalWrite(EL3, LOW); digitalWrite(EL4, HIGH);
  delay(stepDelay);

  digitalWrite(EL1, HIGH); digitalWrite(EL2, LOW);
  digitalWrite(EL3, LOW); digitalWrite(EL4, HIGH);
  delay(stepDelay);
}

void stepElevationDown() {
  digitalWrite(EL1, HIGH); digitalWrite(EL2, LOW);
  digitalWrite(EL3, LOW); digitalWrite(EL4, HIGH);
  delay(stepDelay);

  digitalWrite(EL1, LOW); digitalWrite(EL2, HIGH);
  digitalWrite(EL3, LOW); digitalWrite(EL4, HIGH);
  delay(stepDelay);

  digitalWrite(EL1, LOW); digitalWrite(EL2, HIGH);
  digitalWrite(EL3, HIGH); digitalWrite(EL4, LOW);
  delay(stepDelay);

  digitalWrite(EL1, HIGH); digitalWrite(EL2, LOW);
  digitalWrite(EL3, HIGH); digitalWrite(EL4, LOW);
  delay(stepDelay);
}

// --------------------------------------
void stopMotors() {
  digitalWrite(AZ1, LOW);
  digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, LOW);
  digitalWrite(AZ4, LOW);

  digitalWrite(EL1, LOW);
  digitalWrite(EL2, LOW);
  digitalWrite(EL3, LOW);
  digitalWrite(EL4, LOW);
}
//siren code
#define BUZZER 11

void setup() {
  pinMode(BUZZER, OUTPUT);
}

void loop() {
  tone(BUZZER, 700);   // 500 Hz = mid-range beep
  delay(250);          // beep duration

  noTone(BUZZER);
  delay(1000);          // 250 ms pause between beeps
}
// led test

void setup() {
  pinMode(13, OUTPUT);  // Set D13 as output
}

void loop() {
  digitalWrite(13, HIGH);  // LED ON
  delay(500);              // wait 0.5 seconds

  digitalWrite(13, LOW);   // LED OFF
  delay(500);              // wait 0.5 seconds
}

const int sensorPin = A1;

const float Vref = 5.0;      // Arduino reference voltage
const float R1 = 10000.0;    // resistor from panel + to A1
const float R2 = 10000.0;    // resistor from A1 to GND

void setup() {
  Serial.begin(9600);
}

void loop() {
  int raw = analogRead(sensorPin);

  // Voltage at Arduino pin (0–5V)
  float v_arduino = (raw * Vref) / 1023.0;

  // Real panel voltage (because the divider halves it)
  float v_panel = v_arduino * (R1 + R2) / R2;

  Serial.print("Raw: ");
  Serial.print(raw);

  Serial.print("  | Arduino voltage: ");
  Serial.print(v_arduino, 3);

  Serial.print(" V  | Panel voltage: ");
  Serial.print(v_panel, 3);
  Serial.println(" V");

  delay(500);
}
// Voltage test on A6 with 10k/10k divider

const int sensorPin = A6;

const float Vref = 5.0;        // Arduino analog reference voltage (5V)
const float R1 = 10000.0;      // Top resistor (panel + → A6)
const float R2 = 10000.0;      // Bottom resistor (A6 → GND)

void setup() {
  Serial.begin(9600);
}

void loop() {

  // Raw ADC value (0–1023)
  int raw = analogRead(sensorPin);

  // Voltage at Arduino pin (0–5V)
  float v_arduino = (raw * Vref) / 1023.0;

  // True solar panel voltage using divider ratio (R1 = R2 → x2)
  float v_panel = v_arduino * ( (R1 + R2) / R2 );  // = v_arduino * 2

  Serial.print("RAW: ");
  Serial.print(raw);

  Serial.print("   Arduino pin voltage: ");
  Serial.print(v_arduino, 3);
  Serial.print(" V");

  Serial.print("   Panel voltage: ");
  Serial.print(v_panel, 3);
  Serial.println(" V");

  delay(500);
}
// --------------------------------------
// --------- "SOLAR-ALIGN" --------------
// Simple tracking + LED + Siren + Solar + LDR debug
//
// Robotics and Industrial electronics module
// -MINI-PROJECT-
//
// By Daryl Sweeney
// student number: c22718249
// TU705
// year three
// 
// --------------------------------------
// helped by chat gpt

// ---------- ANALOG INPUTS ----------
// LDR-Solar-Panel-Locations
int LDR_TOP    = A0;  // LDR1
int LDR_BOTTOM = A1;  // LDR2
int LDR_LEFT   = A2;  // LDR3
int LDR_RIGHT  = A3;  // LDR4

// Solar panel voltage (via 10k/10k divider from panel)
// Small 5V fan is in parallel with the panel (no separate current sense)
int SOLAR_VOLT_PIN = A6; 

// ---------- STEPPER PINS ----------
// First driver (Azimuth): IC pins 2,7,10,15 -> D2, D4, D5, D6
int AZ1 = 2;  // driver pin 2 -> D2
int AZ2 = 4;  // driver pin 7 -> D4
int AZ3 = 5;  // driver pin 10 -> D5
int AZ4 = 6;  // driver pin 15 -> D6

// Second driver (Elevation): IC pins 2,7,10,15 -> D7, D8, D9, D10
int EL1 = 7;  // driver pin 2 -> D7
int EL2 = 8;  // driver pin 7 -> D8
int EL3 = 9;  // driver pin 10 -> D9
int EL4 = 10; // driver pin 15 -> D10

// LED
int LED = 13;

// Siren / buzzer pin
int SIREN_PIN = 11;

// ---------- SETTINGS ----------
int deadband  = 50;
int stepDelay = 5;

// ADC reference and divider details
const float Vref      = 5.0;     // Arduino analog reference (5 V)
const float R1_DIV    = 10000.0; // top resistor of divider (10k)
const float R2_DIV    = 10000.0; // bottom resistor (10k)

// Approximate total load resistance (panel load: fan + any resistor)
// CHANGE THIS to your measured / calculated load resistance in ohms
const float LOAD_R    = 36.0;    

// state variable to detect transition from moving → locked
bool wasMoving = false;


// --------------------------------------
void setup() {
  Serial.begin(9600);

  pinMode(AZ1, OUTPUT);
  pinMode(AZ2, OUTPUT);
  pinMode(AZ3, OUTPUT);
  pinMode(AZ4, OUTPUT);

  pinMode(EL1, OUTPUT);
  pinMode(EL2, OUTPUT);
  pinMode(EL3, OUTPUT);
  pinMode(EL4, OUTPUT);

  pinMode(LED, OUTPUT);
  digitalWrite(LED, LOW);

  pinMode(SIREN_PIN, OUTPUT);
  noTone(SIREN_PIN);

  stopMotors();

  Serial.println("SOLAR-ALIGN starting up...");
}


// --------------------------------------
void loop() {

  // ---- Read LDRs ----
  int top    = analogRead(LDR_TOP);
  int bottom = analogRead(LDR_BOTTOM);
  int left   = analogRead(LDR_LEFT);
  int right  = analogRead(LDR_RIGHT);

  // ---- Read solar voltage ----
  int rawVolt = analogRead(SOLAR_VOLT_PIN);

  // Voltage at divider output (A6)
  float v_divider = (rawVolt * Vref) / 1023.0;
  // Real panel voltage (10k / 10k divider → x2)
  float v_panel = v_divider * ((R1_DIV + R2_DIV) / R2_DIV); // = v_divider * 2.0

  // Estimated current using Ohm's law: I = V / R
  // This assumes the panel is effectively loaded by LOAD_R
  float i_panel = 0.0;
  if (LOAD_R > 0.0) {
    i_panel = v_panel / LOAD_R;
  }

  // Differences for tracking
  int vertical   = top - bottom;    // North/South
  int horizontal = right - left;    // East/West

  bool moving = false;

  // ---- NORTH/SOUTH movement ----
  if (abs(vertical) > deadband) {
    moving = true;
    if (vertical > 0) stepElevationUp();
    else              stepElevationDown();
  }

  // ---- EAST/WEST movement ----
  if (abs(horizontal) > deadband) {
    moving = true;
    if (horizontal > 0) stepRight();
    else                stepLeft();
  }

  stopMotors();

  // ---- LED + Siren behaviour (unchanged) ----
  if (moving) {
    // searching mode
    blinkSearching();   // LED blinks
    beepSearching();    // siren short beeps
  } else {
    // locked on source
    digitalWrite(LED, HIGH);   // LED solid ON
    noTone(SIREN_PIN);

    // Just transitioned from moving → locked
    if (wasMoving) {
      // one last longer beep
      tone(SIREN_PIN, 800);   // medium pitch
      delay(400);             // 2x normal beep length
      noTone(SIREN_PIN);

      Serial.println("Aligned to source!");
    }
  }

  wasMoving = moving;

  // ---------- SERIAL OUTPUT (every 1.5s) ----------
  // Line 1: solar panel voltage & estimated current
  Serial.print("SOLAR:  V = ");
  Serial.print(v_panel, 3);
  Serial.print(" V   I_est = ");
  Serial.print(i_panel, 3);
  Serial.println(" A  (I = V / R_load)");

  // Line 2: LDR voltages in a single line
  float vTop    = (top    * Vref) / 1023.0;
  float vBottom = (bottom * Vref) / 1023.0;
  float vLeft   = (left   * Vref) / 1023.0;
  float vRight  = (right  * Vref) / 1023.0;

  Serial.print("LDRs:  A0(top)=");
  Serial.print(vTop, 3);
  Serial.print(" V  A1(bottom)=");
  Serial.print(vBottom, 3);
  Serial.print(" V  A2(left)=");
  Serial.print(vLeft, 3);
  Serial.print(" V  A3(right)=");
  Serial.print(vRight, 3);
  Serial.println(" V");

  Serial.println("------------------------");

  delay(1500);  // 1.5 second gap between each print block
}


// --------------------------------------
// LED BLINK FUNCTION (searching mode)
// --------------------------------------
void blinkSearching() {
  static unsigned long lastToggle = 0;
  static bool ledState = false;

  if (millis() - lastToggle >= 500) {   // 0.5 second blink
    ledState = !ledState;
    digitalWrite(LED, ledState);
    lastToggle = millis();
  }
}


// --------------------------------------
// SIREN BEEP FUNCTION (searching mode)
// --------------------------------------
void beepSearching() {
  static unsigned long lastBeep = 0;
  const unsigned long beepInterval = 500;  // every 0.5s
  const int beepDuration = 150;           // short beep

  if (millis() - lastBeep >= beepInterval) {
    tone(SIREN_PIN, 1000);  // 1 kHz tone
    delay(beepDuration);
    noTone(SIREN_PIN);
    lastBeep = millis();
  }
}


// --------------------------------------
// STEPPER MOVEMENT PATTERNS
// --------------------------------------

// EAST/WEST (Azimuth)
void stepRight() {
  digitalWrite(AZ1, HIGH); digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, HIGH); digitalWrite(AZ4, LOW);
  delay(stepDelay);

  digitalWrite(AZ1, LOW); digitalWrite(AZ2, HIGH);
  digitalWrite(AZ3, HIGH); digitalWrite(AZ4, LOW);
  delay(stepDelay);

  digitalWrite(AZ1, LOW); digitalWrite(AZ2, HIGH);
  digitalWrite(AZ3, LOW); digitalWrite(AZ4, HIGH);
  delay(stepDelay);

  digitalWrite(AZ1, HIGH); digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, LOW); digitalWrite(AZ4, HIGH);
  delay(stepDelay);
}

void stepLeft() {
  digitalWrite(AZ1, HIGH); digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, LOW); digitalWrite(AZ4, HIGH);
  delay(stepDelay);

  digitalWrite(AZ1, LOW); digitalWrite(AZ2, HIGH);
  digitalWrite(AZ3, LOW); digitalWrite(AZ4, HIGH);
  delay(stepDelay);

  digitalWrite(AZ1, LOW); digitalWrite(AZ2, HIGH);
  digitalWrite(AZ3, HIGH); digitalWrite(AZ4, LOW);
  delay(stepDelay);

  digitalWrite(AZ1, HIGH); digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, HIGH); digitalWrite(AZ4, LOW);
  delay(stepDelay);
}


// NORTH/SOUTH (Elevation)
void stepElevationUp() {
  digitalWrite(EL1, HIGH); digitalWrite(EL2, LOW);
  digitalWrite(EL3, HIGH); digitalWrite(EL4, LOW);
  delay(stepDelay);

  digitalWrite(EL1, LOW); digitalWrite(EL2, HIGH);
  digitalWrite(EL3, HIGH); digitalWrite(EL4, LOW);
  delay(stepDelay);

  digitalWrite(EL1, LOW); digitalWrite(EL2, HIGH);
  digitalWrite(EL3, LOW); digitalWrite(EL4, HIGH);
  delay(stepDelay);

  digitalWrite(EL1, HIGH); digitalWrite(EL2, LOW);
  digitalWrite(EL3, LOW); digitalWrite(EL4, HIGH);
  delay(stepDelay);
}

void stepElevationDown() {
  digitalWrite(EL1, HIGH); digitalWrite(EL2, LOW);
  digitalWrite(EL3, LOW); digitalWrite(EL4, HIGH);
  delay(stepDelay);

  digitalWrite(EL1, LOW); digitalWrite(EL2, HIGH);
  digitalWrite(EL3, LOW); digitalWrite(EL4, HIGH);
  delay(stepDelay);

  digitalWrite(EL1, LOW); digitalWrite(EL2, HIGH);
  digitalWrite(EL3, HIGH); digitalWrite(EL4, LOW);
  delay(stepDelay);

  digitalWrite(EL1, HIGH); digitalWrite(EL2, LOW);
  digitalWrite(EL3, HIGH); digitalWrite(EL4, LOW);
  delay(stepDelay);
}


// --------------------------------------
void stopMotors() {
  digitalWrite(AZ1, LOW);
  digitalWrite(AZ2, LOW);
  digitalWrite(AZ3, LOW);
  digitalWrite(AZ4, LOW);

  digitalWrite(EL1, LOW);
  digitalWrite(EL2, LOW);
  digitalWrite(EL3, LOW);
  digitalWrite(EL4, LOW);
}

